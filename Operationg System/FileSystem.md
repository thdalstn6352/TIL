# 1. Project Introduction

<img src="https://images.velog.io/images/thdalstn6352/post/a8272c8f-409e-4fe5-88a6-0f6d8385f216/image.png"/>

파일 시스템이란 파일의 실제 데이터와 메타데이터(파일의 위치, 크기, 소유자, 허가권 등, ls -al로 볼 수 있는 파일정보)를 유지/저장하는 체계로써 파일에 이름을 붙이고, 저장이나 검색을 위해 논리적으로 그것들이 어디에 위치시켜야 하는지 등을 나타내는 방법이다.

윈도우, OS/2, 매킨토시 및 유닉스 기반의 운영체계들은 모두 파일들이 어딘가에 계층적인 구조로 위치하는 파일 시스템을 가지고 있다. 파일은 계층구조 내의 올바른 디렉토리 또는 서브디렉토리 내에 놓여진다.

# 2. Project Goals

앞서 설명한 구조의 파일시스템을 구현하는 것으로, 모든 구현이 완료된 후에 disk.img 파일을 읽어와 마운트 시킨 후, 랜덤으로 10개의 파일 이름을 할당 받은 후 올바른 구조에 따라 해당 파일 이름의 데이터를 출력하는 것이다. 따라서 Mount 완료한 super block의 정보를 모두 출력하고, inode table에 들어있는 모든 정보를 파악하여 원하는 파일을 올바르게 읽어오는지 확인하고 출력하는 것이 이번 프로젝트의 목표이다. 뿐만 아니라 write기능을 추가하여 해당 파일의 데이터를 사용자가 원하는 데이터로 수정될 수 있도록 구현하는 것도 이번 프로젝트에서 해야 할 목표이다.

본 프로젝트를 구현함에 있어 파일시스템의 개념에 대해 이해하고, 구조, 특징 역할등을 파악하여 파일시스템이 필요한 이유에 대해서 생각하며, 각종 파일시스템의 종류를 알아보고 차이점을 찾아 파일시스템에 대한 이론을 숙지하는 것이 이번 프로젝트의 목적이다.

파일시스템의 이론을 확립하여 실제 파일시스템에서 작동하는 open, read, write를 구현하며, 추가 directory생성, 다수 사용자의 공유 파일사용 등 여러 명령을 어떻게 가능하도록 할지에 대해서 알아보도록한다.

# 3. Concepts used in CPU simulation

## 1) 파일시스템(File System)

### 1-1) 파일시스템이란?

<img src="https://images.velog.io/images/thdalstn6352/post/c2687e99-6c24-4574-83b4-35731cbea62a/image.png"/>

컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관 또는 조직하는 체제를 가리키는 말이다. 저장 매체의 크기가 증가 할수록 보관하는 파일의 수 또한 점점 증가하게 되어 별도의 관리 시스템이 필요하다. 따라서 개발된 것이 파일시스템이다. 파일시스템 종류에는 UFS, FAT16, FAT32, NTFS, ext2, ext3, ext4, HFS+ 등이 있다.

### 1-2) 파일이란?

파일은 프로그램 또는 데이터 등과 같은 정보들의 집합을 말한다. 이러한 정보를 저장할 수 있는 기억장소 공간은 디스크에 할당되어 있으며 디스크에 존재하는 여러 파일들은 각자 고유한 이름을 가짐으로서 구별된다.

### 1-3) 파일시스템 구조

파일시스템은 파일에 대한 메타데이터 즉, 파일 데이터의 데이터가 저장된 영역과 실제 데이터가 기록된 영역 2가지로 구분된다.

<img src="https://images.velog.io/images/thdalstn6352/post/1b3e6700-ed7b-4afc-81f3-5ad806ea8162/image.png"/>

**메타 영역(Meta Area)** : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간정보, 삭제유무 등 파일의 정보
**데이터 영역(Data Area)** : 파일의 데이터

### 1-4) 파일시스템 특징

⦁ 계층적(Hierarchical) 디렉터리 구조를 가진다.
⦁ 디스크 파티션 별로 하나씩 둘 수 있다.

### 1-5) 파일시스템 역할

⦁ 파일관리 : 파일 저장, 참조, 공유
⦁ 보조 저장소 관리 : 저장 공간 할당
⦁ 파일 무결성 메커니즘 : 파일이 의도한 정보만 포함하고 있음을 의미
⦁ 접근 방법 : 저장된 데이터에 접근할 수 있는 방법 제공

### 1-6) 파일시스템 목적

⦁ HDD와 메인 메모리 속도차 줄이기
⦁ 파일 관리 용이
⦁ HDD의 막대한 용량을 효율적으로 이용

### 1-7) 파일시스템은 왜 필요한가?

파일은 정보를 저장할 수 있는 기억장소공간이 디스크에 할당되어 있으며 디스크에 존재하는 다른 파일들과 구별할 수 있는 고유의 이름이 존재한다. 여기서 디스크란 소멸하지 않는 기억장치이다. 다시 말해 디스크에 저장된 데이터나 프로그램, 즉 파일은 프로세스가 수행을 완료하고 사라진 후에라도 여전히 남아있게 된다. 디스크는 고정된 블록단위로 데이터를 저장하게 된다. 모든 디스크의 입력과 출력은 섹터(물리적 레코드)단위로 이뤄진다. 연속적인 바이트로 구성된 파일이 일정 바이트로 나뉘어져 디스크 곳곳에 저장된다. 이때, 한 가지 문제점은 사용자는 블록에 관한 정보를 아무것도 모른다는 점이다. 메모리는 바이트 단위로 읽어 들일 수 있지만 디스크는 바이트 단위로 읽어 들일 수 없는 구조로 되어 있다. 그렇기에 파일 시스템이 파일과 디스크 블록 간에 밀접한 연결 작업을 해주어야 한다.

## 2) 파일시스템 마운팅

파일이 사용되기 전에 수행하는 작업으로 파일 시스템은 프로세스들에 의해 사용되기 전에 mount 되어야 한다.

즉, 운영체제(OS)에게 장치의 이름과 파일 위치가 주어진다. 일반적으로 마운트 포인트는 장착되는 파일 시스템이 부착될 비어있는 디렉토리이다. 운영체제(OS)는 장치가 유효한 파일 시스템을 포함하는지 확인한다. 그 과정은 장치 드라이버가 장치 디렉토리를 읽고 디렉토리가 유효한 포맷을 가지고 있는지 확인하도록 요청함으로써 이루어진다. 운영체제는 파일 시스템이 지정된 마운트 포인트에 장착되었음을 디렉토리 구조에 기록한다. 이 기법은 운영체제가 디렉토리 구조를 순회하고 파일 시스템을 적절히 교체할 수 있게 한다.

## 3) 파일시스템(File System) 모델

<img src="https://images.velog.io/images/thdalstn6352/post/d2446dd1-9d27-4bf8-8801-98d3a45c0f2f/image.png"/>

### 3-1) 슈퍼블록(Super Block)

UFS(Unix File System)에서 슈퍼블록은 수많은 정보들을 포함하고 있다. 이러한 값들로 파일시스템에 레이아웃을 정의 할 수 있는 것이다.
super block에 있는 filesystem 상태를 기술하는 여러 field를 보면,

- filesystem의 크기
- filesystem 내의 free block 수
- inode의 list 크기
- filesystem 내의 free inode 수
- filesystem 내의 free inode의 list
- free inode list의 다음 free inode의 index
- free block list와 free inode list를 위한 lock field들이 있다.

### 3-2) inode(Index node)

process가 disk의 file을 access하기 위한 도구로 'inode table = inode list'를 이용한다.
어느 한 file이나 directory가 만들어질 경우 그에 해당되는 하나의 inode가 만들어 지고 그 inode가 inode list에 등록되는데, 이 때 등록된 번호를 'inode number'라 한다.
inode 하나는 64 byte의 크기이고, 어떤 file이나 directory에 대한 모든 정보가 해당 inode에 담겨져 있어 file을 대표한다.

하나의 inode에 담겨진 내용을 보면 다음과 같다. - file type, access mode - link된 갯수 - file의 크기(byte수) - file이 마지막으로 access, write되고 inode가 change된 시간 - 'direct'로 data block을 가리키는 12 pointer의 array - 'indirect' pointer - file에 의해 사용된 physical block의 수

**※ file의 크기와 'inode의 data block pointer'의 관계**

- file의 최대 크기 : ① + ② + ③ 하면 된다.
  ① 'direct' pointer 12 개 : 8192 x 12 / 1024 = 96 Kbyte
  ② 'single indirect' pointer 1 개 : 8192 x 2048 / 1024 = 16 Mbyte
  ③ 'double indirect' pointer 1 개 : 8192 x 2048 x 2048 /1024 = 32 Gbyte

### 3-3) Data block

데이터블록은 inode 에 포함된다. inode 는 몇 개의 data block 을 포함하고 있으며, 각 데이터 블록은 파일들의 데이터를 실제로 저장하고 있다.

### 3-4) Indirection block

간접 블록은 추가적인 데이터 블록을 사용하기 위한 포인터들이 할당되는 공간이다. 실제로 inode 는 적은 수의 데이터블록을 갖고 있으며 더 많은 데이터블록이 필요할 경우 이를 동적으로 가리킬 포인터가 저장된다.

### 3-5) directory file

<img src="https://images.velog.io/images/thdalstn6352/post/6e78dddc-77fa-4ec7-8059-86bcf7ad9d8b/image.png"/>

- directory는 file 이름들의 저장 창고와 같다.
- directory는 각 file의 이름과 그 file 자체를 서로 연결시켜 주는 역할을 하므로 file 시스템의 전체적 구조를 결정지어 준다.
- directory는 많은 file들을 포함하며 또한 마찬가지로 여러 file들을 갖는 sub directory를 가질 수 있다.
- directory는 ordinary file과 구별되는 개념이지만 읽힐 때는 ordinary file과 똑같이 행동한다.
- 모든 directory는 적어도 '.'와 '..'라는 file을 가지고 있어야 하는데, '.'은 directory file 자체를 지시하고 '..'은 그 directory의 상위 directory를 나타낸다. 이들 file들을 이용하여 전체 file 시스템을 루트에서부터 차례로 내려오면서 모든 file을 탐색할 수 있다.

- pathname(경로명)
  모든 file은 자신이 속해 있는 directory가 있으므로 어느 한 file을 지정하기 위해서는 그 file명은 물론 그 File이 속해 있는 directory name도 지정해야 한다. 따라서 file을 지정하기 위해서는 관련 directory name과 file명 그리고 '/'로 이루어지는 pathname(경로명)이 필요하다. - 절대 path - 상대 path

### 3-6.1) 디렉토리 구조(Directory Structure)

** 1단계 디렉토리 (Single Level Directory)**

<img src="https://images.velog.io/images/thdalstn6352/post/72585ab5-4846-4624-a413-c3b09f4dd64b/image.png"/>

모든 파일이 한 개의 디렉토리 밑에 있는 개념으로 같은 디렉토리에 모든 파일이 존재 하므로 각 파일은 유일한 이름을 가져야 한다. 따라서 다수의 사용자에게 제약이 크다.

** 2단계 디렉토리(Two Level Derictory)**

<img src="https://images.velog.io/images/thdalstn6352/post/dde4bbf0-8956-43f0-b164-9a376a88a48a/image.png"/>

각 사용자는 자신만의 사용자 파일 디렉토리(User File Directory, UFD)를 가지고 있으며 UFD는 비슷한 구조를 가지고 있지만 각 디렉토리에는 오직 한 사람의 파일 만을 저장한다.

사용자의 작업이 시작되거나 시스템에 사용자가 로그인을 통해 접속하면 시스템은 마스터 파일 디렉토리(Master File Directory, MFD)를 먼저 탐색한다. MFD는 사용자 이름이나 계정 번호로 색인되어 있으며 각 항목은 그 사용자의 UFD를 가리키고 있다.

2단계 디렉토리 구조에서 파일 이름이 충돌하는 문제는 어느 정도 해결하였으나 한 사용자의 UFD를 다른 사용자가 접근을 할 수 없기 때문에 파일을 공유해서 사용하는 경우는 공유가 불가능하다. 따라서 접근을 허용하려면 한 사용자가 다른 사용자의 디렉토리에 있는 파일을 지칭 할 수 있어야 한다.

** 트리 구조 디렉토리(Tree Structure Directory)**

<img src="https://images.velog.io/images/thdalstn6352/post/a9d7508d-e66d-4257-a8c1-0e64bd807eee/image.png"/>

여러 단계로 확장하는 일반적인 방법의 임의의 높이를 갖는 트리 구조이다. 일반 사용자들에게 자신의 서브디렉토리(subdirectory)를 얼마든지 만들 수 있게 해준다. 트리는 가장 일반적인 디렉토리 구조이다.

** 비순환 그래프 디렉토리(Acyclic Graph Directory)**

<img src="https://images.velog.io/images/thdalstn6352/post/f4c93d83-4ccd-4d43-a2ab-93e2abd13ba6/image.png"/>

트리 구조는 파일 또는 디렉토리의 공유를 허용하지 않는다. 비순환 그래프는 디렉토리들이 서브디렉토리들과 파일 들을 공유할 수 있도록 허용하는 구조로 똑같은 파일이나 서브디렉토리가 서로 다른 서브디렉토리에 있을 수 있다. 비순환 그래프는 트리 구조 디렉토리 방식을 일반화한 것이다.

파일을 공유하는 방법으로는 링크(link)라 불리는 새로운 디렉토리 항목을 만드는 것과 디렉토리들이 동일한 항목 내용을 복사해서 가지고 있는 방법이 있다. 후자의 경우에는 일관성에 문제가 발생한다. 링크의 경우는 다른 파일이나 서브디렉토리를 가리키는 포인터를 가지고 참조한다. 디렉토리를 검색할 때 디렉토리 항목이 링크로 표시되어 있다면 실제 파일 이름을 링크 정보에 포함되어 있다. 실제 파일에 대한 경로 이름을 사용함으로써 링크를 해석(resolve) 한다.

** 일반 그래프 디렉토리(General Graph Directory)**

<img src="https://images.velog.io/images/thdalstn6352/post/0700fcac-4f72-4990-b21a-e08ad2041326/image.png" />

비순환 그래프 트리 구조에 있어서 중요한 문제점은 순환이 발생하지 않도록 어떻게 보장하느냐는 것이다. 2단계 디렉토리부터 시작해서 사용자가 서브디렉토리를 생성하면 트리 구조가 형성된다. 단순히 새로운 파일이나 디렉토리를 기존의 트리 구조 디렉토리에 추가하는 것은 트리 구조의 성질을 유지 하지만 기존의 트리에 새로운 링크를 추가하면 트리 구조는 파괴되고 일반적인 그래프 구조가 될 수 있다.

비순환 그래프의 장점은 파일을 검색하고 파일에 대한 참조의 존재 여부를 결정하는 알고리즘이 비교적 간단하다는 것이다. 하지만 성능적인 측면에서 비순환 그래프의 공유 부분을 두 번 순회하는 것은 좋지 않다. 잘못 설계된 알고리즘은 계속 탐색하고 종료하지 못하는 무한 루프에 빠질 수도 있다. 한 가지 해결책은 한 번에 검색 할 수 있는 디렉토리의 숫자를 임의로 제한하는 것이다.

### 3-7) Meta data

파일 사용자 ID, 파일 형태, 크기, 저장장소, 정보의 장소(offset), 버퍼, 시간 정보(생성시간, 최근 읽기,쓰기된 시간)등의 정보들이 저장된 데이터를 의미한다. 파일에 접근하는데 필요한 정보를 가진 Meta data가 있어야 파일이 제대로 관리될 수 있으며 이들은 디스크 내부에 파일과 별도로 저장된다.

### 3-8) 버퍼 캐쉬(buffer cache)

파일 사용자와 디스크의 사이에 자리 잡고 완충 역할을 하게 되는 장치이다. 파일을 사용할 때마다 디스크에서 일일이 읽어오려면 속도가 상당히 느리다. 따라서 처음 읽은 파일은 버퍼 캐쉬에 내용을 저장해 둠으로써 이후 사용자가 동일한 파일을 사용하길 원할 때 읽어오는 속도를 높일 수 있는 것이다. 바로 파일에 접근하는 것도 지역적 성격을 갖고 있기 때문에 버퍼 캐쉬를 사용할 수 있는 것이다. 그러나 버퍼 캐쉬가 무한정의 메모리를 사용할 수는 없다. 그러므로 용량의 제한으로 버퍼 캐쉬에 저장된 목록을 교체해야 한다. 이때 앞서 메모리 관리에서 배운 LRU Policy가 일반적으로 쓰인다. 이러한 버퍼 캐쉬는 시스템에 하나만 존재한다. 이유는 버퍼 캐쉬 상에 변화가 생기면 해당 변화를 다른 장치들도 알고 있어야 하기 때문이다.

## 4) 파일 시스템 구현 (File System Implementation)

<img src="https://images.velog.io/images/thdalstn6352/post/c8ba5cbe-d285-4440-ac2b-e89aa0d4aa6f/image.png"/>
앞서 설명하였듯 파일을 사용하려면 파일이 반드시 열려야 하며 open() 호출은 파일 시스템에 파일 이름을 넘겨준다. open() 시스템 호출은 먼저 그 파일이 다른 프로세스에 사용 중인지 범 시스템 오픈 파일 테이블을 찾으며 이 알고리즘은 오버헤드를 줄이는데 도움이 된다. 또한 디렉토리 연산의 속도를 향상 시키기 위해 통상 디렉토리 구조의 일부는 메모리에 캐싱한다.

파일이 발견되면 FCB가 메모리 내의 범 시스템 오픈 파일 테이블에 복사된다. 테이블은 FCB와 프로세스의 수도 저장한다. 범 시스템 오픈 파일 테이블 안에는 테이블의 항목에 대한 포인터와 몇 개의 다른 필드를 갖는 프로세스 별 항목이 만들어진다. 이 필드들 파일 안의 현재 위치(다음 read() 또는 write() 연산이 시작되는 위치)를 가리키는 포인터와 파일이 열린 접근 모드 등을 포함한다.

Open() 호출은 프로세스 별 파일 시스템 테이블 내의 해당 항목에 대한 포인터를 찾아 돌려준다. 그 후 모든 파일 연산은 이 포인터를 통해 실행된다. 일단 해당 FCB를 디스크에서 찾으면 시스템은 파일 이름을 더 이상 사용하지 않기 때문에 파일 이름은 오픈 파일 테이블의 한 부분이 아니다. 그러나 같은 파일에 대한 차후 open() 연산을 빠르게 하기 위해 캐시될 수 있다. 유닉스에서는 파일 기술자라 부르고 Windows에서는 파일 핸들이라 부른다.

파일을 닫지 않는 이상 모든 파일 연산은 오픈 파일 테이블에서 이루어진다. 프로세스가 파일을 닫을 때 프로세스 별 테이블 항목이 삭제되며 범 시스템 항목의 오픈 계수는 감소 된다. 사용자가 열었던 모든 파일을 닫으면 갱신된 메타데이터 정보가 디스크 기반 디렉토리 구조에 복사되며 시스템 오픈 파일 테이블에서 그 항목이 삭제된다.

<img src="https://images.velog.io/images/thdalstn6352/post/17e33d08-5813-4645-a72f-502367c87a01/image.png"/>

이런 구조들은 캐싱 기법을 사용함으로써 실제 자료 블록을 제외한 오픈 파일에 대한 모든 정보는 메모리 내에 존재한다. 디스크 입/출력 작업을 줄일 수 있다.

사용자는 지역 디스크의 여러 파일 시스템이나 네트워크를 통하여 이용 가능한 파일 시스템에 접근할 수 있다. 구현 세부 사항으로부터 기본 시스템 호출 기능을 격리시키기 위해 자료 구조와 프로시저가 사용 된다. 일반적으로 파일 시스템 인터페이스, VFS 인터페이스, 지역 파일 시스템 으로 세 가지 주요한 계층으로 구성되어 있다.

파일 시스템 인터페이스는 open(), read(), write(), close() 호출과 파일 기술자에 기반을 둔 인터페이스이다. 가상 파일 시스템(VFS, Virtual File System)은 VFS 인터페이스를 명확하게 정의함으로써 파일 시스템의 일반적 연산을 구현과 분리 시킨다. VFS 인터페이스에 대한 다른 구현들이 같은 기계 상에 공존할 수 있으므로 다른 형태의 파일 시스템을 지역적으로 장착함으로써 투명한 접근을 가능하게 한다. 또한 전체 네트워크에 걸쳐 파일을 유일하게 표시할 수 있는 기법을 제공한다. vnode라는 전체 네트워크에서 파일을 유일하게 만들어주는 수치 지정자(designator)를 포함하고 있다. VFS는 특정 파일 시스템 고유의 연산을 활성화시킴으로써 파일 시스템 유형에 따른 지역 요청들을 처리하며 원격 요청에 대해서는 NFS 프로토콜 프로시저를 호출 한다. 파일 핸들은 연관된 vnode 들로부터 구성되며 이들 프로시저에 매개변수로 전달 된다.

## 5) 파일시스템(File System)의 종류

### 5-1) FAT (File Allocation Table)

Microsoft에서 빌게이츠가 만들었으며 전 세계적으로 가장 많이 사용되는 파일시스템이다. 최초 제작 시에는 저장장치의 크기가 매우 작았으며 여러 번의 발전을 거듭하여 제작하였다. 매우 단순한 구조와 최근에는 대용량을 위해서 FAT16, FAT32 등으로 발전되었다.

#### ① FAT16 (File Allocation Table)

MS-DOS를 개발할 당시 사용하던 파일 시스템으로 윈도우 95, 윈도우 98, 윈도우 NT, 윈도우 2000 등에서 사용되며 대부분의 MS OS에서 호환이 된다는 장점이 있다.

그러나 하나의 파티션으로 최대 2GB 밖에 설정을 할 수 없고, 보안이나 암호화 및 압축 기능들을 지원하지 않는 단점이 있다. 또한, 한 클러스터에 1632KB를 할당하여 용량 낭비가 심하다.

#### ② FAT32

FAT 파일 시스템을 보강한 파일시스템으로 FAT 파일시스템은 2GB 밖에 지원하지 않던 문제를 해결하여 2TB까지 지원한다. 영문 256문자 ( 한글 128 문자 ) 까지 파일 이름 지원한다. 뿐만아니라 클러스터당 4K 배정하여 용량 낭비가 줄어들었다는 장점이 있다. 하지만 FAT16 과 마찬가지로 보안, 암호, 압축 기능을 지원하지 않는다.

### 5-2) NTFS (New Technology File System)

MS에서 FAT가 서버용으로 부족하자 이를 보완하기 위해 만든 파일시스템으로 Window NT에서 사용되는 파일시스템으로 윈도우 NT 및 2000 이상부터 대표적인 파일시스템으로 자리 잡았다. NTFS 는 대용량 하드 지원, 보안과 암호화 또한 지원. 별도의 압축 프로그램 없이도 파일과 폴더를 압축할 수 있다. 클러스터 크기는 512byte ~ 64KB까지 지원하며, 기본적으로 4KB를 지원한다. 뿐만 아니라 파일 접근 속도 최적화, 이론적으로 거의 무제한의 하드 디스크 공간 관리. 긴 파일 이름, 디스크 손실 방지, 자체적 오류 수정, 트랜잭션 로깅, 디렉토리 및 파일 수준의 보안, 충돌 보호, 실시간 압축 등을 지원한다.

### 5-3) HPFS (High Performance File System)

IBM의 OS/2 1.2부터 사용되던 파일시스템으로 NTFS가 나오기 전 많은 영향을 준 파일 시스템으로 제작당시 대용량에 적합한 구조로 효율적인 캐싱과 FAT에 비해 파일 손실과 단편화가 적기에 서버시스템에 많은 요구를 충족시키던 파일 시스템으로 알려져 있다. 하지만 대용량을 타겟으로 잡기에 200MB 이하의 저장장치에서는 성능 저하 문제가 발생한다.

5-4) UFS (Unix File System)
UFS는 유닉스의 대표적인 파일시스템으로 많은 유닉스 계열의 OS들이 UFS를 각각의 OS에 맞게 변형해서 사용하고 있다. 빠른 속도와 안정성을 목표로 만들어졌다. 저장장치 그룹화를 통하여 관련된 데이터끼리 최대한 가까운 위치에 자리 잡아 헤드의 이동이 적다. 중요 데이터는 여러 그룹에 걸쳐 많은 백업을 저장하여 신뢰성을 높였다.

Berkeley대학의 FFS(Fast File System)을 근간으로 리눅스 파일시스템인 Ext2에 큰 영향을 주었다.

### 5-5) Ext2 (second Extended File System)

현재 리눅스의 기본 파일시스템인 Ext3에서 저널링 기능을 뺀 파일 시스템으로 UFS의 유명무실한 구조를 제거하고 전체 구조보다 간략히 하여 속도와 안정성을 고루 갖춘다.
